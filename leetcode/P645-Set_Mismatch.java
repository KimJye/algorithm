/**
두 번 발생하는 숫자와 누락된 숫자를 찾아 배열 형태로 반환
 */
// 배열 크기는 최소 2부터다.
//    
/**
[1,2,2,4]
[1,1]

첫번째 생각
반복문을 돈다 1부터 주어진 배열 크기만큼 돈다. 
반복문을 돌면서 i값과 비교하는데, 다르면 빈 배열에 추가하고 해당 i 값을 넣는다. 그리고 리턴

두번째 생각
[3,2,2]  case
정답은 [2,1]

2,2,3 으로 정렬해서 풀어야겠음.

세번째 생각
[3,2,3,4,6,5] case 
정답은 [3,1]

정렬하면, [2,3,3,4,5,6] 
음 그냥 처음에 1을 넣어주는게 마음 편하지만, 1을 넣어준다고 가정을하고 하기

네번째 생각
[2,2] case
정답은 [2,1]


다섯번째 생각
[1,5,3,2,2,7,6,4,8,9] case
정답은 [2,10]

[1,2,2,3,4,5,6,7,8,9]
다음것과 비교해서 누락이 없으면, 배열 길이 만큼의 값이 정답으루..

여섯번재 생각
[5,3,6,1,5,4,7,8] case
[1,3,4,5,5,6,7,8] 정렬
정답은 [5,2] 

누락과 중복이 동시에 있을거라는 착각...
누락과 중복이 같은 탐색내에서 확인이 불가능하다는 것을 깨달음..
다양한 케이스 생각이 부족햇다. 따라서 누락, 중복 따로 탐색하여 찾기로 결정.

일곱번째 생각
[37,62,43,27,12,66,36,18,39,54,61,65,47,32,23,2,46,8,4,24,29,38,63,39,25,11,45,28,44,52,15,30,21,7,57,49,1,59,58,14,9,40,3,42,56,31,20,41,22,50,13,33,6,10,16,64,53,51,19,17,48,26,34,60,35,5]

현재와 이전이 2이상 차이나면 누락임
 */
 
 class Solution {
     public int[] findErrorNums(int[] nums) {
        int [] result = new int[2];

        Arrays.sort(nums);
         
        // find duplicate number
        for (int i=0; i< nums.length-1; ++i) {
            if (nums[i] == nums[i + 1]) {
                result[0] = nums[i];
                break;
            }
        }
         
        // find missing number
        for (int i=1; i< nums.length; ++i) {
            if (nums[0] != 1) {
                result[1] = 1;
                break;
            }
            
            if (nums.length == 2) {
                result[1] = nums.length;
                break;
            }
            
            if (nums[i] - nums[i-1] > 1) {
                result[1] = nums[i-1] +1;
            }
            if (result[1] == 0) result[1] = nums.length;
        }

        return result;
    }
}
