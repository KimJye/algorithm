<알고리즘 시간 분석>

* 반복문의 중첩된 횟수
	- 상수 시간(고정된 반복, 데이터 갯수,크기에 비례하지 않는)
	- n에 비례( 데이터 갯수에 비례하는)

*stack hip data segement
	stack segement - 지역변수, 파라미터변수:(함수 호출시 생성/ 리턴시 소멸)
			- 메소드 호출, 함수 호출 관련 변수들이 여기에 만들어짐

	hip segement    - new 에서 만들어지는.govege 콜렉션 하면 없어짐
			- 모든 객체, 배열(자바언어(문법상)만/c언어는 배열이 객체가 아님)

	data segement - 메모리에 올라갈때(맨처음부터(클래스)) 만들어지고 끝까지 있음. 
			- static member 변수


*재귀 알고리즘에서
	n-1,n-2,n-3...->n의 비례
	n/2,n/3.n/4...->logn 비례

*재귀적인 구조 - 어떤 문제 안에 크기만 다를 뿐 성격이 똑같은 작은 문제들이 포함되어있는 것
		- ex) binary tree 등 트리 구조.
1. 현재 단계 작업 구현
2. 다음 단계 작업 재귀호출
3. 종료 조건 if 문 추가
	
**구현실습
	sum(파라미터로 배열 주어지거나  n을 주어진 경우) 재귀로 알고리즘 해보기**


public class Sum{
	static int sum(int n){
		return n+sum(n-1);
	}
	public static void main(String[] args){
		for(int i=0;i<=10;i++)
		



*알고리즘 시간 복잡도 -계수는 무시하고 차수(지수)만 신경쓴다.

* 퀵sort
	- 문제: 배열A를 정렬한다.
	- 입력: 배열 A, 배열의 크기는 n

	(1)A를 반으로 쪼갠다 -> 현재 단계
	(2) 기준값으로 배열을 쪼개기 (기준값보다 작은것은 왼쪽/큰값은 오른쪽)-> 현재 단계
	(3) 각각 정렬 ->  재귀호출
	(4) 쪼개진 배열의 크기가 1이면 -> 종료 조건

시간복잡도: nlogn(쪼개는 부분이 logn, merge할때 n)

* merge sort
	(1) A를 반으로 쪼갠다
	(2) 또 반으로 쪼갠다
	(3) 각각 쪼갠다
	(4) 하나씩 비교 -> merge 하면서 섞기
시간 복잡도: nlogn(쪼개는 부분이 logn, merge할때 n)