20180618 <DFS and BFS>
graph : node들이 link로 연결된 자료구조

Tree : 임의의 두 node 사이의 경로가 1개. 

Tree는 Graph의 부분집합

* node는 정점, link는 간선

* 그래프를 2차원 배열로 정의해 놓을때 경로의 최솟값을 구하라.

* ArrayList와 Hash맵 사용하거나 linked List로 구현한다.

*무향 그래프-in java
- key가 character, value는 string타입으로 
- map은 부모 인터페이스이고 hashmap은 map을 상속한 클래스이다.
- 가급적 객체를 부모타입에 대입해야 바람직하다. 이유는 다형성 때문이다.
다형성을 구현하는 3가지 조건 중 하나가 부모타입의 변수를 사용해야 한다가 있다.(* 다형성 공부할 것)
- 다형성을 구현한다는 것은 hashmap과 호환되는 다른 객체가 있다는 것인데 map인터페이스를 구현한 Treemap 클래스가 있다.
- map 인터페이스를 구현한 클래스는 haspMap과 Treemap 클래스가 있다.
- 호환되는 객체가 있다는 것은 객체지향 언어의 목표(다형성)이다.
- key로 value를 등록해놓고 key로 꺼내는 자료구조는 map이다.
- hashmap은 hash로 구현되어있고 Treemap은 레드블랙트리로 구현되어있다.
- jdk 설치파일에 들어가면 src.zip파일이 있다. 여기에 소스코드를 까보자.

*유향 그래프-in java
- key는 string, value는 string배열
- 타입변수 똑같으면 생략할 수 있다.

* 가중치 있는 유향 그래프 - in java
- 노드 이름도 저장해야하고 가중치도 저장해야하니까 클래스를 따로 만드는게 좋다.
- 인접정점(정점, 가중치 변수) 클래스를 만든다.
- key가 string, value는 인접정점[]목록 배열
- map.put("철수",new 인접정점[](new 인접정점("영희",8), new 인접정점("동건",6).....

*너비우선탐색(BFS), 깊이우선탐색(DFS)
- 그동안 학습한 재귀호출이 깊이우선탐색이었다.(DFS)
- 최단경로를 찾을때는 둘중 어떤게 더 나을까?

* BFS 사례
- 시작점으로부터 시작해서 가까운 순서로 방문하는 것이다.
- 인접한 정점들 중에서 아직 방문하지 않은 정점들을 순서대로 모두 방문한다. 
- 각 정점을 딱 한번만 방문한다. 그래서 사용한 간선들만 남기면 트리가 된다. 두 노드사이에 경로가 딱 한개라면 트리이기 때문이다. => 너비우선트리

* BFS 구현
- HashMap key 타입은 character, value 타입은 string
- HashSet<character> 방문한정점 // 방문했냐 안했냐 목록
- Queue<character> 다음에방문할정점목록 = new LinkedList<character>// bfs 를 구현할때는 queue가 필요하다.
	queue에서는 먼저 발견한게 꺼내진다. 즉 root에서 가까운 노드부터 탐색한다.
	발견된 노드들을 다음에 방문할정점목록에 넣는다.(아직 방문안한것들만)
	현재 노드에 인접한 노드들을 찾은 뒤에 그 중에서 아직 방문안한것들을 다음에 방문할정점목록에 add하고
	가장 먼저 넣은것을 꺼내게된다.

- 방문한 정점.add(시작정점)
- 다음에방문할정점목록.add(시작정점)
- while( 다음에방문할정점목록.isEmpty()==false){

* set 인터페이스를 implements한 클래스는 HashSet클래스, TreeSet클래스가 있다.
- 집합형태로
- Hash테이블로 구현한 HashSet 의 장단점 : 성능은 상수, 최악의 경우가 꽉찼을때이다. best경우는 비어있는 경우. 평균치 성능은 hashSet이 좀 더 좋다. 평균성능이 의미하는것은 자바코드로 돌려보면 그렇다.
- 레드블랙트리로 구현한 TreeSet 의 장단점 : 성능은 logn, 최악의 경우가 없다. 언제나 logn이다. 
- 들어있느냐 안들어있느냐만 확인할 때. 몇개 들어있는지는 확인할 필요가 없기 떄문에 set을 쓴다.
- 중복 없다.
- 똑같은거 들어있으면 메모리 낭비다.

* queue 와 stack 
- best search를 구현할 때.
- queue 와 stack 사용사례 알아보기!!
- queue의 활용 : bfs 
- stack 활용 : dfs

* queue 인터페이스를 implements 한 대표적이 LinkedList 클래스.
* List 인터페이스를 implements한 대표적 클래스는 LinkedList, ArrayList 클래스가 있다.

* DFS 활용 사례
- 한쪽 경로로 갈 수 있을 때까지 간 다음에 더이상 못가면 돌아오고 그 다음 경로를 시도하는 방식.

*DFS 구현 - 재귀호출
- 메소드가 2개이다. 그 이유는 처음호출할때와 재귀호출된 메소드의 파라미터 목록이 다르기 때문이다.

* linkedList 들어있는 숫자중에 5의 배수들을 더해서 구하기 재귀호출로!!
* hashtable의 구현 방법 설명하라. hashTable에서 충돌 해결전략 설명하라.
* DFS 재귀호출이 아닌 반복으로 구현하라.
* 이진트리의 search 재귀호출이 아닌 반복으로 구현하라.
* 이진트리 inorder 재귀호출이 아닌 반복으로 구현하라.

*그래프와 포레스트의 차이
- 트리가 여러개 모인 것을 포레스트라고 한다.

* inputStream() 메소드 알아보기!!!

